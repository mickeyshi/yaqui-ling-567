;;; -*- Mode: TDL; Coding: utf-8 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Grammar of Hiaki
;;; created at:
;;;     Thu Feb 25 17:15:03 UTC 2021
;;; based on Matrix customization system version of:
;;;     Fri Feb  5 21:00:23 UTC 2021
;;;
;;; Sources: "An Introduction to Hiaki Grammar": Hiaki Grammar for
;;; Learners and Teachers, Volume 1.
;;; 
;;; Current repo at
;;; https://github.com/mickeyshi/yaqui-ling-567/tree/master
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Type assigning empty mod list. Added to basic types for nouns, verbs and determiners.

non-mod-lex-item := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < > ].

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Matrix Type Addenda
;;;;;;;;;;;;;;;;;;;;;;;;;

basic-head-comp-phrase :+ [ SYNSEM [ LIGHT -,
             LOCAL.CAT.MC #mc ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

head :+ [ PRON bool,
    INIT bool,
    AUX bool,
    PRD bool,
    NMZ bool,
    POSSESSOR poss,
    SPEC-INIT bool,
    FORM form ].

+nd :+ [ CASE case ].

coord-phrase :+ [ SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz ].

unary-bottom-coord-rule :+ [ SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz ] > ].

inflected :+ [ POSSESSED-MARKED-AA-NOUN-FLAG luk,
    VERB-PC61-OR-VERB-PC62-FLAG luk,
    VERB-PC59-FLAG luk,
    VERB-PC60-FLAG luk,
    TENSE-MARKED-VERB-PC-FLAG luk,
    VERB-PC59-OR-VERB-PC60-FLAG luk,
    NUMBERED-CASED-NOUN_PC-FLAG luk,
    1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG luk ].

infl-satisfied :+ [ POSSESSED-MARKED-AA-NOUN-FLAG na-or-+,
    VERB-PC61-OR-VERB-PC62-FLAG na-or-+,

    VERB-PC59-FLAG na-or-+,
    VERB-PC60-FLAG na-or-+,
    TENSE-MARKED-VERB-PC-FLAG na-or-+,
    VERB-PC59-OR-VERB-PC60-FLAG na-or-+,
    NUMBERED-CASED-NOUN_PC-FLAG na-or-+,
    1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG na-or-+ ].

png :+ [ PER person,
    NUM number ].

cat :+ [ POSSESSUM poss ].

poss := *top* &
  [ POSS-AGR png ].

basic-bare-np-phrase :+ [ SYNSEM.LOCAL.CAT [ VAL.SPEC < >,
                       HEAD #head,
                       POSSESSUM #possessum ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD #head,
                                POSSESSUM #possessum & nonpossessive ] ].

basic-head-1st-comp-phrase :+ [ SYNSEM.LOCAL.CAT.POSSESSUM #poss,
    HEAD-DTR.SYNSEM.LOCAL.CAT.POSSESSUM #poss ].

basic-head-opt-subj-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

basic-determiner-lex :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR nonpossessive,
                       POSSESSUM nonpossessive ] ].

poss-case := case.

top-coord-rule :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                       POSSESSUM #possessum ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ] ].

mid-coord-rule :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                       POSSESSUM #possessum ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ] ].

bottom-coord-phrase :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                       POSSESSUM #possessum ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                   POSSESSUM #possessum ] ].

adj-head-int-phrase :+ [ HEAD-DTR.SYNSEM.NON-LOCAL.SLASH.LIST < > ].

;;;;;;;;;;;;;;
;;; Features
;;;;;;;;;;;;;;

;;; Case

case := *top*.
real-case := case.  ; intermediate case type for all real cases
nom := real-case & nom+acc.  ; nom
acc := real-case & nom+acc.  ; acc
ins := real-case.  ; ins
all := real-case.  ; all
gen := real-case.  ; gen
loc := real-case.  ; loc
dat := real-case.  ; dat
com := real-case.  ; com
dir := real-case.  ; dir
sup := real-case.  ; supe
nom+acc := case.

;;; Person

person := *top*.
1st := person.
non-1st := person.
2nd := non-1st.
3rd := non-1st.

;;; Number

number := *top*.
pl := number.
sg := number.

;;; Possession

possession := *top*.
possessive := poss.  ; supertype for possessive features
nonpossessive := poss.  ; type for nonpossessive
possessor := possessive.
possessum := possessive.
possessive-pron-1 := possessive.  ; supertype for strategy pron-1
possessor-pron-1 := possessor & possessive-pron-1.
possessum-pron-1 := possessum & possessive-pron-1.

;;; Possession

possessive-pron-2 := possessive.  ; supertype for strategy pron-2
possessor-pron-2 := possessor & possessive-pron-2.
possessum-pron-2 := possessum & possessive-pron-2.

;;; Form

form := *top*.
nonfinite := form.
finite := form.

;;; Tense

pst := tense.
non-pst := tense.
prs := non-pst.
fut := non-pst.

;;; Aspect

cmpl := pfv.
incep := aspect.
rel := aspect.
no-aspect := aspect.
hab := aspect.
prog := ipfv.
prosp+ipfv+pfv := aspect.
prosp := prosp+ipfv+pfv.
ipfv := prosp+ipfv+pfv & ipfv+pfv.
pfv := prosp+ipfv+pfv & ipfv+pfv.
ipfv+pfv := aspect.

;;; Mood

ind := mood.
irr := mood.
imp := mood.
sbjv := mood.
directive := mood.
desid := mood.
quot := mood.
ev := mood.

;;;;;;;;;;;;;;;;;;;
;;; Lexical Types
;;;;;;;;;;;;;;;;;;;

;;; Nouns

wh-pronoun-noun-lex := basic-wh-word-lex & norm-hook-lex-item & basic-icons-lex-item & non-mod-lex-item & zero-arg-que &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun,
                           VAL [ SPR < >,
                                 SUBJ < >,
                                 COMPS < >,
                                 SPEC < > ] ],
                     CONT [ RELS.LIST < [ LBL #larg,
                                          ARG0 #arg0 & ref-ind ],
                                        quant-relation &
                                        [ PRED "wh_q_rel",
                                          ARG0 #arg0,
                                          RSTR #harg ] >,
                            HCONS.LIST < [ HARG #harg,
                                           LARG #larg ] > ] ],
             NON-LOCAL.QUE.LIST < #arg0 > ] ].

noun-lex := basic-noun-lex & basic-non-wh-word-lex & non-local-none-lex-item & no-hcons-lex-item & non-mod-lex-item &
  [ ARG-ST < #spr >,
    SYNSEM.LOCAL.CAT [ VAL [ SPR < #spr &
                                   [ LOCAL.CAT.HEAD det ] >,
                             COMPS < >,
                             SUBJ < >,
                             SPEC < > ],
                       HEAD [ NMZ -,
                              POSSESSOR nonpossessive ],
                       POSSESSUM nonpossessive ] ].

no-spr-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT + ] > ].

; Nouns which cannot take specifiers mark their SPR requirement
; as OPT +.  Making the non-head daughter OPT - in this rule
; keeps such nouns out.
; 
; Rules for building NPs.  Note that the Matrix uses SPR for
; the specifier of nouns and SUBJ for the subject (specifier) of verbs.

head-spec-phrase := basic-head-spec-phrase & head-final &
  [ NON-HEAD-DTR.SYNSEM [ OPT -,
                          LOCAL.CAT [ POSSESSUM #poss,
				      VAL.SPEC < [ LOCAL.CAT.POSSESSUM #poss ] > ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.POSSESSUM #poss ].

common_noun-noun-lex := noun-lex & noun-pc14-rule-dtr & numbered-cased-noun_pc-rule-dtr & post-nom-acc-marked-noun-pc-rule-dtr &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd,
    INFLECTED [ POSSESSED-MARKED-AA-NOUN-FLAG -,
                NUMBERED-CASED-NOUN_PC-FLAG - ] ].

2nd-pl-acc-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 2nd,
                                         NUM pl ],
                   CAT.HEAD [ PRON +,
                              CASE acc ] ] ].

3rd-sg-acc-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 3rd,
                                         NUM sg ],
                   CAT.HEAD [ PRON +,
                              CASE acc ] ] ].

3rd-sg-nom-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 3rd,
                                         NUM sg ],
                   CAT.HEAD [ PRON +,
                              CASE nom ] ] ].

3rd-sg-reflexive-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 3rd,
                                         NUM sg ],
                   CAT.HEAD [ PRON +,
                              CASE acc ] ] ].

all-pronoun-2-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRON +,
                            CASE all ] ].

2nd-pl-nom-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 2nd,
                                         NUM pl ],
                   CAT.HEAD [ PRON +,
                              CASE nom ] ] ].

2nd-sg-nom-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 2nd,
                                         NUM sg ],
                   CAT.HEAD [ PRON +,
                              CASE nom ] ],
    INFLECTED.1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG + ].

2nd-sg-acc-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 2nd,
                                         NUM sg ],
                   CAT.HEAD [ PRON +,
                              CASE acc ] ] ].

1st-sg-nom-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 1st,
                                         NUM sg ],
                   CAT.HEAD [ PRON +,
                              CASE nom ] ],
    INFLECTED.1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG + ].

1st-pl-nom-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 1st,
                                         NUM pl ],
                   CAT.HEAD [ PRON +,
                              CASE nom ] ] ].

1st-pl-refl-pronoun-noun-lex := noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRON +,
                   CONT.HOOK.INDEX.PNG [ PER 1st,
                                         NUM pl ] ] ].

1st-sg-nom-acc-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 1st,
                                         NUM sg ],
                   CAT.HEAD [ PRON +,
                              CASE nom+acc ] ] ].

all-pronoun-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRON +,
                            CASE all ] ].

3rd-pl-nom-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 3rd,
                                         NUM pl ],
                   CAT.HEAD [ PRON +,
                              CASE nom ] ] ].

3rd-pl-acc-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 3rd,
                                         NUM pl ],
                   CAT.HEAD [ PRON +,
                              CASE acc ] ] ].

what-noun-noun-lex := wh-pronoun-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom+acc ].

who-nom-noun-noun-lex := wh-pronoun-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom ].

who-acc-noun-noun-lex := wh-pronoun-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE acc ].

where-noun-noun-lex := wh-pronoun-noun-lex.

when-noun-noun-lex := wh-pronoun-noun-lex.

1st-pl-acc-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD [ PRON +,
                              CASE acc ],
                   CONT.HOOK.INDEX.PNG [ NUM pl,
                                         PER 1st ] ] ].

generic-pronoun-noun-lex := no-spr-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.PRON +,
    INFLECTED.1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG + ].

short-3rd-sg-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD [ PRON +,
                              CASE acc ],
                   CONT.HOOK.INDEX.PNG [ NUM sg,
                                         PER 3rd ] ] ].

short-3rd-pl-pronoun-noun-lex := generic-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD [ PRON +,
                              CASE acc ],
                   CONT.HOOK.INDEX.PNG [ NUM pl,
                                         PER 3rd ] ] ].

poss-pron1-noun-lex := non-local-none-lex-item &
  [ SYNSEM [ LKEYS.ALTKEYREL #altkeyrel & noun-relation &
                             [ PRED "pron_rel",
                               LBL #ltop,
                               ARG0 #possessor &
                                    [ COG-ST activ-or-more,
                                      SPECI + ] ],
             LOCAL [ CONT [ HOOK [ INDEX #possessor,
                                   LTOP #ltop ],
                            RELS.LIST < #altkeyrel >,
                            HCONS.LIST < > ],
                     CAT [ VAL [ SPR < [ LOCAL.CAT.HEAD det,
                                         OPT + ] >,
                                 COMPS olist,
                                 SUBJ olist,
                                 SPEC < > ],
                           HEAD noun &
                                [ PRON +,
                                  POSSESSOR possessor-pron-1,
                                  CASE poss-case ] ] ] ] ].

1st-sg-possessive-noun-lex := poss-pron1-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ PER 1st,
                                       NUM sg ] ].

1st-pl-possessive-noun-lex := poss-pron1-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                       PER 1st ] ].

2nd-sg-possessive-noun-lex := poss-pron1-noun-lex.

2nd-pl-possessive-noun-lex := poss-pron1-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                       PER 2nd ] ].

3rd-sg-possessive-alt-noun-lex := poss-pron1-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ NUM sg,
                                       PER 1st ] ].

3rd-pl-possessive-noun-lex := poss-pron1-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                       PER 3rd ] ].

poss-pron2-noun-lex := non-local-none-lex-item &
  [ SYNSEM [ LKEYS.ALTKEYREL #altkeyrel & noun-relation &
                             [ PRED "pron_rel",
                               LBL #ltop,
                               ARG0 #possessor &
                                    [ COG-ST activ-or-more,
                                      SPECI + ] ],
             LOCAL [ CONT [ HOOK [ INDEX #possessor,
                                   LTOP #ltop ],
                            RELS.LIST < #altkeyrel >,
                            HCONS.LIST < > ],
                     CAT [ VAL [ SPR < [ LOCAL.CAT.HEAD det,
                                         OPT + ] >,
                                 COMPS olist,
                                 SUBJ olist,
                                 SPEC < > ],
                           HEAD noun &
                                [ PRON +,
                                  POSSESSOR possessor-pron-2,
                                  CASE poss-case ] ] ] ] ].

3rd-sg-possessive-noun-lex := poss-pron2-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                       PER 3rd ] ].

;;; Verbs

verb-lex := non-mod-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT [ HC-LIGHT -,
                         HEAD verb &
                              [ NMZ - ] ] ] ].

main-verb-lex := verb-lex & basic-verb-lex & basic-non-wh-word-lex & applicative-verb-pc-rule-dtr & causative-verb-pc-rule-dtr & completed-verb-rule-dtr & could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr & directive-verb-pc-or-start-stop-verb-pc-rule-dtr & go-pl-pc-rule-dtr & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc33-rule-dtr & verb-pc6-rule-dtr & verb-pc7-rule-dtr & verb-pc9-rule-dtr &
  [ SYNSEM [ L-QUE -,
             LOCAL [ CAT [ HEAD.AUX -,
                           VAL [ SPEC < >,
                                 SUBJ < #subj > ] ],
                     CONT.HOOK.XARG #xarg ] ],
    ARG-ST.FIRST #subj &
                 [ LOCAL [ CAT cat-sat &
                               [ VAL [ SPR < >,
                                       COMPS < > ] ],
                           CONT.HOOK.INDEX #xarg ] ] ].

aux-lex := verb-lex & basic-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.HEAD [ AUX +,
                              INIT - ] ] ].

intransitive-verb-lex := main-verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE real-case ] ] >,
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG - ].

transitive-verb-lex := main-verb-lex & transitive-lex-item &
  [ ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE real-case ] ],
             #comps &
             [ LOCAL.CAT cat-sat &
                         [ VAL [ SPR < >,
                                 COMPS < > ],
                           HEAD noun &
                                [ CASE real-case ] ] ] >,
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG -,
    SYNSEM.LOCAL.CAT [ VAL.COMPS < #comps >,
                       HEAD.INIT - ] ].

clausal-verb-lex := main-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
    ARG-ST < [ LOCAL.CAT.HEAD noun ],
             #comps &
             [ LOCAL.CAT [ MC na-or--,
                           VAL [ SPR < >,
                                 COMPS < >,
                                 SUBJ < > ] ] ] > ].

nom-intransitive-verb-lex := intransitive-verb-lex &
  [ ARG-ST.FIRST.LOCAL.CAT.HEAD noun &
                                [ CASE nom ] ].

nom-acc-transitive-verb-lex := transitive-verb-lex &
  [ ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE nom ] ],
             [ LOCAL.CAT.HEAD noun &
                              [ CASE acc ] ] > ].

clausal-nom-verb-lex := clausal-verb-lex &
  [ ARG-ST.FIRST.LOCAL.CAT.HEAD noun &
                                [ CASE nom ] ].

transitive-verb-verb-lex := nom-acc-transitive-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE nom,
                           COMPS.FIRST.LOCAL.CAT.HEAD.CASE acc ],
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG - ].

intransitive-verb-verb-lex := nom-intransitive-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CAT.HEAD.CASE nom,
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG - ].

irr-intransitive-pl-subject-verb-verb-lex := nom-intransitive-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl,
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG - ].

irr-intransitive-sg-subject-verb-verb-lex := nom-intransitive-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg,
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG - ].

irr-transitive-sg-object-verb-verb-lex := nom-acc-transitive-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg,
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG - ].

irr-transitive-pl-object-verb-verb-lex := nom-acc-transitive-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl,
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG - ].

go-sg-pres-verb-verb-lex := nom-intransitive-verb-lex &
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg,
                   CONT.HOOK.INDEX.E.TENSE non-pst ] ].

go-pl-pres-verb-verb-lex := nom-intransitive-verb-lex &
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl,
                   CONT.HOOK.INDEX.E.TENSE non-pst ] ].

go-sg-pst-verb-verb-lex := nom-intransitive-verb-lex &
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg,
                   CONT.HOOK.INDEX.E.TENSE pst ] ].

go-pl-pst-verb-verb-lex := nom-intransitive-verb-lex &
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl,
                   CONT.HOOK.INDEX.E.TENSE pst ] ].

think-clausal-complement-verb-verb-lex := clausal-nom-verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM [ NON-LOCAL.QUE.LIST < >,
             LOCAL.CAT [ VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE nom,
                               COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                            [ FORM finite ],
                                                       WH.BOOL - ],
                                                 CONT.HOOK.INDEX.SF prop ] ] > ],
                         HEAD.INIT + ] ],
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG - ].

ask-clausal-complement-verb-verb-lex := clausal-nom-verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE nom,
                             COMPS < [ LOCAL [ CONT.HOOK.INDEX.SF ques,
                                               CAT [ HEAD verb &
                                                          [ FORM finite ],
                                                     WH.BOOL + ] ] ] > ],
                       HEAD.INIT + ],
    INFLECTED.TENSE-MARKED-VERB-PC-FLAG - ].

;;; Auxiliaries

arg-comp-aux := aux-lex & non-local-none-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPEC < >,
                             COMPS < #comps . #vcomps >,
                             SUBJ < #subj &
                                    [ LOCAL.CAT.HEAD.CASE real-case ] > ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CAT [ HEAD noun,
                             VAL [ SUBJ < >,
                                   SPR < >,
                                   SPEC < >,
                                   COMPS < > ] ],
                       CONT.HOOK.INDEX #xarg ] ],
             #comps &
             [ LIGHT +,
               LOCAL [ CAT [ VAL [ SUBJ < [ ] >,
                                   COMPS #vcomps ],
                             HEAD verb ],
                       CONT.HOOK.XARG #xarg ] ] > ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

arg-comp-aux-with-pred := arg-comp-aux & hcons-lex-item &
  [ SYNSEM [ LOCAL.CONT.HCONS.LIST < qeq &
                                     [ HARG #harg,
                                       LARG #larg ] >,
             LKEYS.KEYREL event-relation &
                          [ ARG1 #harg ] ],
    ARG-ST < [ ],
             [ LOCAL.CONT.HOOK.LTOP #larg ] > ].

aux1-aux-lex := arg-comp-aux-with-pred & verb-pc59-rule-dtr & verb-pc60-rule-dtr &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E.ASPECT ipfv,
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ],
    INFLECTED.VERB-PC59-OR-VERB-PC60-FLAG - ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

aux2-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E [ TENSE fut,
                                       ASPECT prosp+ipfv+pfv ],
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ],
    INFLECTED.VERB-PC61-OR-VERB-PC62-FLAG - ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

aux3-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E.ASPECT ipfv+pfv,
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ] ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

aux4-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

aux5-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

aux6-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E [ TENSE fut,
                                       ASPECT prosp+ipfv+pfv ],
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ] ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

aux7-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E.ASPECT ipfv+pfv,
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ] ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

aux8-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E [ TENSE fut,
                                       ASPECT pfv,
                                       MOOD sbjv ],
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ] ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

aux10-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E.ASPECT ipfv,
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ] ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

aux11-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

neg12-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Note that raise-sem-lex-item assumes the first complement is
; where the HOOK comes from.  It's not clear to me how you'd
; tell that you had an argument composition auxiliary if it
; wasn't appearing adjacent to the verb.

; To keep the semantically empty ones from spinning on
; generation, require complement to be [AUX -].  The
; FORM feature might be enough in the starter grammars,
; but I don't want to rely on this.  Then again, [ AUX - ]
; might not be true.

arg-comp-aux-no-pred := arg-comp-aux & raise-sem-lex-item &
  [ ARG-ST < [ ],
             [ LOCAL.CAT.HEAD.AUX - ] > ].

aux13-aux-lex := arg-comp-aux-no-pred & verb-pc59-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite,
    INFLECTED.VERB-PC59-FLAG - ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Note that raise-sem-lex-item assumes the first complement is
; where the HOOK comes from.  It's not clear to me how you'd
; tell that you had an argument composition auxiliary if it
; wasn't appearing adjacent to the verb.

; To keep the semantically empty ones from spinning on
; generation, require complement to be [AUX -].  The
; FORM feature might be enough in the starter grammars,
; but I don't want to rely on this.  Then again, [ AUX - ]
; might not be true.

aux14-aux-lex := arg-comp-aux-no-pred &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E [ ASPECT ipfv,
                                       MOOD imp ],
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ] ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Note that raise-sem-lex-item assumes the first complement is
; where the HOOK comes from.  It's not clear to me how you'd
; tell that you had an argument composition auxiliary if it
; wasn't appearing adjacent to the verb.

; To keep the semantically empty ones from spinning on
; generation, require complement to be [AUX -].  The
; FORM feature might be enough in the starter grammars,
; but I don't want to rely on this.  Then again, [ AUX - ]
; might not be true.

aux15-aux-lex := arg-comp-aux-no-pred & verb-pc60-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite,
    INFLECTED.VERB-PC60-FLAG - ].

; Somewhat surprisingly, this used to inherit from basic-two-arg (when we had lexical threading), so
; that the non-local features were previously amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Note that raise-sem-lex-item assumes the first complement is
; where the HOOK comes from.  It's not clear to me how you'd
; tell that you had an argument composition auxiliary if it
; wasn't appearing adjacent to the verb.

; To keep the semantically empty ones from spinning on
; generation, require complement to be [AUX -].  The
; FORM feature might be enough in the starter grammars,
; but I don't want to rely on this.  Then again, [ AUX - ]
; might not be true.

aux26-aux-lex := arg-comp-aux-no-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ].

;;; Copulas

cop-lex := basic-verb-lex-super & trans-first-arg-raising-lex-item-2 & non-mod-lex-item &
  [ SYNSEM.LOCAL [ CONT.HOOK.XARG #xarg,
                   CAT [ VAL [ COMPS < [ LOCAL.CAT cat-sat &
                                                   [ HEAD.PRD +,
                                                     VAL [ SUBJ < >,
                                                           COMPS < > ] ] ] >,
                               SPEC < >,
                               SUBJ < [ LOCAL [ CONT.HOOK.INDEX #xarg,
                                                CAT cat-sat &
                                                    [ VAL [ SPR < >,
                                                            COMPS < > ],
                                                      HEAD noun &
                                                           [ CASE real-case ] ] ] ] > ],
                         HEAD.INIT - ] ] ].

; Copula type taking adjectival complements.
; Need to define more for additional complement types.

adp-comp-copula-verb-lex := cop-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD adp ].

available-copula-cop-lex := adp-comp-copula-verb-lex.

;;; Adjectives

adj-lex := basic-intersective-adjective-lex.

basic_adjective-adj-lex := attr-adj-lex &
  [ SYNSEM  [ NON-LOCAL non-local-none,
	      LOCAL [ CAT [ VAL.SUBJ < [ 
					      LOCAL [ CAT [ HEAD noun &
						     [ CASE nom ],
						VAL [ SPR < >,
						      COMPS < > ] ], 
						      CONT [
						      HOOK.INDEX #index
						      ] ] ] >,
			    HEAD.PRD + ] ,
		      CONT.HOOK.XARG #index ] ] ].

; Basic attributive adjective definition

attr-adj-lex := adj-lex & intersective-mod-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD noun,
                                              VAL.SPR cons ] ] > ].


;;; Complementizers

;;; Others

norm-adposition-lex := norm-sem-lex-item & no-hcons-lex-item & basic-intersective-mod-lex & non-local-none-lex-item &
  [ ARG-ST < #comp >,
    SYNSEM [ LKEYS.KEYREL arg12-ev-relation &
                          [ PRED #pred,
                            ARG2 #ind ],
             L-QUE #lque,
             LOCAL [ CONT.RELS.LIST < [ PRED #pred,
                                        ARG0 event,
                                        ARG1 event-or-ref-index ] >,
                     CAT [ WH.BOOL -,
                           VAL [ SPR < >,
                                 SPEC < >,
                                 SUBJ < >,
                                 COMPS < #comp &
                                         [ L-QUE #lque,
                                           LOCAL [ CAT [ HEAD verb
                                                         ],
                                                   CONT.HOOK.INDEX #ind ] ] > ],
                           HEAD adp &
                                [ MOD < [ LOCAL.CAT [ VAL.SPR cons,
                                                      WH.BOOL -,
                                                      HEAD.AUX - ] ] > ] ] ] ] ].

normadp1-norm-adposition-lex := norm-adposition-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.INIT + ].

;;; Determiners
;;; SPEC is non-empty, and already specified by basic-determiner-lex.

determiner-lex := basic-determiner-lex & basic-non-wh-word-lex & norm-zero-arg & non-mod-lex-item &
  [ SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < > ],
                       HEAD.INIT - ] ].

det1-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

det2-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL [ CAT.HEAD.CASE nom,
                                              CONT.HOOK.INDEX.PNG.NUM sg ] ] ].

det3-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

wh-determiner-lex := basic-wh-word-lex & basic-determiner-lex & non-mod-lex-item & zero-arg-nonslash &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < >,
                             SPEC.FIRST.LOCAL.CONT.HOOK.INDEX #arg0,
                             COMPS < >,
                             SUBJ < > ],
             NON-LOCAL.QUE.LIST < #arg0 > ] ].

det4-determiner-lex := wh-determiner-lex & one-icons-lex-item.

det5-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL [ CAT.HEAD.CASE nom,
                                              CONT.HOOK.INDEX.PNG.NUM sg ] ] ].

det6-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ] ].

det7-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ] ].

det8-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL [ CAT.HEAD.CASE acc,
                                              CONT.HOOK.INDEX.PNG.NUM sg ] ] ].

det9-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

det10-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

det11-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd,
                                                                  NUM pl ] ] ].

det12-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 1st,
                                                                  NUM sg ] ] ].

det13-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ] ].

det15-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAT.HEAD.CASE all ] ].

det16-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

det17-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ] ].

det18-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

det19-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL [ CAT.HEAD.CASE nom,
                                              CONT.HOOK.INDEX.PNG.NUM sg ] ] ].

det20-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ] ].

det21-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ] ].

det22-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

det23-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd,
                                                                  NUM sg ] ] ].

det24-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

det25-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL [ CAT.HEAD.CASE acc,
                                              CONT.HOOK.INDEX.PNG.NUM sg ] ] ].

det26-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL [ CAT.HEAD.CASE acc,
                                              CONT.HOOK.INDEX.PNG.NUM sg ] ] ].

;;; Adverbs

adverb-lex-item := nonscop-adverb-lex &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < >,
                                 SPEC < >,
                                 SPR < >,
                                 COMPS < > ],
                           HEAD adv &
                                [ MOD < [ LOCAL [ CAT.HEAD verb,
                                                  CONT.HOOK [ CLAUSE-KEY #clause,
                                                              LTOP #ltop ] ] ] > ] ],
                     CONT [ RELS.LIST < [ LBL #ltop,
                                          ARG0 event,
                                          ARG1 #clause,
                                          ARG2 #ind ],
                                        [ PRED #pred,
                                          ARG0 #ind,
                                          LBL #larg ],
                                        [ ARG0 #ind,
                                          RSTR #harg ] >,
                            HOOK.LTOP #ltop,
                            HCONS.LIST < qeq &
                                         [ HARG #harg,
                                           LARG #larg ] > ] ],
             LKEYS.KEYREL [ PRED #pred,
                            ARG0 ref-ind & #ind,
                            LBL #ltop ] ] ].

manner-adverb-lex-item := adverb-lex-item.
;&  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED "manner_nonsp_rel" ].

adverb-lex := basic-non-wh-word-lex & adverb-lex-item & norm-zero-arg &
  [ SYNSEM.LOCAL.CONT.RELS.LIST < [ ],
                                  [ ],
                                  [ PRED "exist_q_rel" ] > ].

clause_modifier-adverb-lex := manner-adverb-lex-item & adverb-lex.

loc-adverb-lex-item := adverb-lex-item &
  [ SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.PRED "loc_nonsp_rel" ].

location_modifier-adverb-lex := loc-adverb-lex-item & adverb-lex.

time_modifier-adverb-lex := loc-adverb-lex-item & adverb-lex.

wh-adverb-lex := basic-wh-word-lex & adverb-lex-item & zero-arg-que &
  [ SYNSEM [ LOCAL.CONT.RELS.LIST < [ ],
                                    [ ARG0 #arg0 ],
                                    quant-relation &
                                    [ PRED "wh_q_rel" ] >,
             NON-LOCAL.QUE.LIST < #arg0 > ] ].

how_or_shall_modifier-adverb-lex := manner-adverb-lex-item & wh-adverb-lex.

where_question_adverb-adverb-lex := loc-adverb-lex-item & wh-adverb-lex.

when_question_adverb-adverb-lex := loc-adverb-lex-item & wh-adverb-lex.

; Type for negative adverbs.
; 
; This adverb should go through a specialized phrase structure rule
;                           included with this grammar.

neg-adv-lex := basic-scopal-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < >,
                             SPEC < > ],
                       POSTHEAD -,
                       HEAD.MOD < [ LOCAL.CAT [ HEAD verb,
                                                VAL [ SUBJ cons,
                                                      COMPS null ] ] ] > ] ].

;;;;;;;;;;;;;;;;;;;
;;; Lexical Rules
;;;;;;;;;;;;;;;;;;;

low-nominalization-lex-rule := cat-change-with-ccont-lex-rule &
  [ SYNSEM.LOCAL.CAT [ HEAD noun &
                            [ NMZ +,
                              MOD #mod ],
                       VAL [ SUBJ < [ LOCAL [ CAT.VAL.SPR < >,
                                              CONT.HOOK.INDEX #subj ] ] >,
                             SPEC #spec,
                             SPR < [ OPT + ] > ],
                       MC #mc,
                       MKG #mkg,
                       HC-LIGHT #hc-light,
                       POSTHEAD #posthead ],
    C-CONT [ RELS.LIST < [ PRED "nominalized_rel",
                           LBL #ltop,
                           ARG0 #arg0 & ref-ind,
                           ARG1 #arg1 ] >,
             HCONS.LIST < qeq &
                          [ HARG #arg1,
                            LARG #larg ] >,
             HOOK [ XARG #xarg,
                    INDEX #arg0,
                    LTOP #ltop ] ],
    DTR.SYNSEM.LOCAL [ CAT [ HEAD.MOD #mod,
                             VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #subj ] >,
                                   SPEC #spec ],
                             MC #mc,
                             MKG #mkg,
                             HC-LIGHT #hc-light,
                             POSTHEAD #posthead ],
                       CONT.HOOK [ XARG #xarg,
                                   LTOP #larg ] ] ].

low-nmz-subjid-compsid-lex-rule := low-nominalization-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS #comps,
                           SUBJ #subj ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ COMPS #comps,
                               SUBJ #subj ] ].

;;; Intermediate rule types

verb-pc7-rule-dtr := word-or-lexrule.
verb-pc33-rule-dtr := word-or-lexrule.
directive-verb-pc-or-start-stop-verb-pc-rule-dtr := word-or-lexrule.
verb-pc6-rule-dtr := word-or-lexrule.
irrealis-verb-pc-rule-dtr := word-or-lexrule.
post-nom-acc-marked-noun-pc-rule-dtr := word-or-lexrule.
could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr := word-or-lexrule.
verb-pc59-rule-dtr := word-or-lexrule.
tense-marked-verb-pc-rule-dtr := word-or-lexrule.
noun-pc14-rule-dtr := word-or-lexrule.
verb-pc16-rule-dtr := word-or-lexrule.
verb-pc1-rule-dtr := word-or-lexrule.
verb-pc60-rule-dtr := word-or-lexrule.
causative-verb-pc-rule-dtr := word-or-lexrule.
past-impfv-verb-pc-rule-dtr := word-or-lexrule.
applicative-verb-pc-rule-dtr := word-or-lexrule.
verb-pc23-rule-dtr := word-or-lexrule.
go-pl-pc-rule-dtr := word-or-lexrule.
numbered-cased-noun_pc-rule-dtr := word-or-lexrule.
verb-pc9-rule-dtr := word-or-lexrule.
completed-verb-rule-dtr := word-or-lexrule.

;;; Lexical rule types

instrumental-marked-noun-pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & noun-pc14-rule-dtr & numbered-cased-noun_pc-rule-dtr & post-nom-acc-marked-noun-pc-rule-dtr &
  [ INFLECTED #infl,
    DTR common_noun-noun-lex &
        [ INFLECTED #infl ] ].

noun-pc3_lrt2-lex-rule := instrumental-marked-noun-pc-lex-rule-super &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE ins,
                   CONT.HOOK.INDEX.PNG.NUM pl ] ].

noun-pc3_lrt4-lex-rule := instrumental-marked-noun-pc-lex-rule-super.

noun-pc3_lrt5-lex-rule := instrumental-marked-noun-pc-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.NUM sg,
                   CAT.HEAD.CASE nom ] ].

possessed-marked-aa-noun-lex-rule-super := lex-rule & numbered-cased-noun_pc-rule-dtr & post-nom-acc-marked-noun-pc-rule-dtr &
  [ INFLECTED [ POSSESSED-MARKED-AA-NOUN-FLAG +,
                VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                VERB-PC59-FLAG #verb-pc59,
                VERB-PC60-FLAG #verb-pc60,
                TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ],
    DTR common_noun-noun-lex &
        [ INFLECTED [ VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                      VERB-PC59-FLAG #verb-pc59,
                      VERB-PC60-FLAG #verb-pc60,
                      TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                      VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                      NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                      1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ] ] ].

possessum-lex-rule-pron-2 := cat-change-only-lex-rule &
  [ SYNSEM.LOCAL.CAT [ HEAD #head & noun &
                            [ POSSESSOR nonpossessive ],
                       POSSESSUM possessum-pron-2,
                       VAL [ SPEC #spec,
                             COMPS #comps,
                             SPR < [ LOCAL.CAT [ VAL.SPR < >,
                                                 HEAD +nd ] ] > ] ],
    DTR.SYNSEM.LOCAL.CAT [ HEAD #head &
                                [ PRON - ],
                           VAL [ COMPS #comps,
                                 SPEC #spec ] ] ].

possessed-noun_lrt1-lex-rule := infl-lex-rule & possessed-marked-aa-noun-lex-rule-super & possessum-lex-rule-pron-2.

nonpossessive-lex-rule-pron-2 := add-only-no-ccont-rule &
  [ SYNSEM.LOCAL.CAT [ HEAD noun &
                            [ POSSESSOR nonpossessive ],
                       POSSESSUM nonpossessive ] ].

nonpossessed-noun_lrt2-lex-rule := const-lex-rule & nonpossessive-lex-rule-pron-2 & possessed-marked-aa-noun-lex-rule-super.

numbered-cased-noun_pc-lex-rule-super := add-only-no-ccont-rule & post-nom-acc-marked-noun-pc-rule-dtr &
  [ INFLECTED [ NUMBERED-CASED-NOUN_PC-FLAG +,
                POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                VERB-PC59-FLAG #verb-pc59,
                VERB-PC60-FLAG #verb-pc60,
                TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ],
    DTR numbered-cased-noun_pc-rule-dtr &
        [ INFLECTED [ POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                      VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                      VERB-PC59-FLAG #verb-pc59,
                      VERB-PC60-FLAG #verb-pc60,
                      TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                      VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                      1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun & na ] ] ].

plural-nom-or-acc-noun-lrt-lex-rule := infl-lex-rule & numbered-cased-noun_pc-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.NUM pl,
                   CAT.HEAD.CASE nom+acc ] ].

singular-nom-noun-lrt-lex-rule := const-lex-rule & numbered-cased-noun_pc-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.NUM sg,
                   CAT.HEAD.CASE nom ] ].

singular-acc-noun-lrt-lex-rule := infl-lex-rule & numbered-cased-noun_pc-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.NUM sg,
                   CAT.HEAD.CASE acc ] ].

singular-locative-noun_lrt-lex-rule := infl-lex-rule & numbered-cased-noun_pc-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.NUM sg,
                   CAT.HEAD.CASE loc ] ].

plural-locative-noun_lrt-lex-rule := infl-lex-rule & numbered-cased-noun_pc-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.NUM pl,
                   CAT.HEAD.CASE loc ] ].

post-nom-acc-marked-noun-pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR post-nom-acc-marked-noun-pc-rule-dtr &
        [ INFLECTED #infl ] ].

comitative-noun-pc10_lrt1-lex-rule := post-nom-acc-marked-noun-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE com ].

directional-noun-pc10-lrt2-lex-rule := post-nom-acc-marked-noun-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE dir ].

superessive-noun-pc10-lrt3-lex-rule := post-nom-acc-marked-noun-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE sup ].

noun-pc14-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & numbered-cased-noun_pc-rule-dtr & post-nom-acc-marked-noun-pc-rule-dtr &
  [ INFLECTED #infl,
    DTR noun-pc14-rule-dtr &
        [ INFLECTED #infl ] ].

noun-pc14_lrt1-lex-rule := noun-pc14-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pst ].

noun-pc23-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & noun-pc14-rule-dtr & numbered-cased-noun_pc-rule-dtr & post-nom-acc-marked-noun-pc-rule-dtr &
  [ INFLECTED #infl,
    DTR common_noun-noun-lex &
        [ INFLECTED #infl ] ].

noun-pc23_lrt1-lex-rule := noun-pc23-lex-rule-super.

verb-pc1-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR verb-pc1-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc1_lrt1-lex-rule := verb-pc1-lex-rule-super.

directive-verb-pc-lex-rule-super := infl-lex-rule & tense-marked-verb-pc-rule-dtr & val-change-with-ccont-lex-rule & verb-pc1-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR directive-verb-pc-or-start-stop-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

directive-verb-pc_lrt-lex-rule := added-arg2of3-applicative-lex-rule & added-arg2of3-np-head-lex-rule & directive-verb-pc-lex-rule-super & same-cont-lex-rule &
  [ C-CONT.RELS.LIST < [ PRED "_direct_rel" ] >,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD directive ].

past-impfv-verb-pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR past-impfv-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

past-impfv-verb-pc_lrt-lex-rule := past-impfv-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ TENSE pst,
                                     ASPECT ipfv ] ].

verb-pc6-lex-rule-super := add-only-no-ccont-rule & completed-verb-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR verb-pc6-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc6_lrt1-lex-rule := verb-pc6-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD sbjv ].

verb-pc6_lrt2-lex-rule := verb-pc6-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD quot ].

verb-pc7-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR verb-pc7-rule-dtr &
        [ INFLECTED #infl ] ].


verb-pc7_lrt2-lex-rule := verb-pc7-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT ipfv ].

causative-verb-pc-lex-rule-super := applicative-verb-pc-rule-dtr & completed-verb-rule-dtr & directive-verb-pc-or-start-stop-verb-pc-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & val-change-with-ccont-lex-rule & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc33-rule-dtr & verb-pc7-rule-dtr & verb-pc9-rule-dtr &
  [ INFLECTED #infl,
    DTR causative-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

causative-transitive-verb-pc-lrt-lex-rule := causative-to-arg2-tr-op-lex-rule & causative-verb-pc-lex-rule-super & same-non-local-lex-rule &
  [ C-CONT.RELS.LIST < [ PRED "causative_rel" ] > ].

causative-intransitive-verb-pc-lrt-lex-rule := causative-to-arg2-itr-op-lex-rule & causative-verb-pc-lex-rule-super & same-non-local-lex-rule &
  [ C-CONT.RELS.LIST < [ PRED "causative_rel" ] > ].

verb-pc9-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR verb-pc9-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc9_lrt1-lex-rule := verb-pc9-lex-rule-super.

tense-marked-verb-pc-lex-rule-super := add-only-no-ccont-rule & verb-pc7-rule-dtr &
  [ INFLECTED [ TENSE-MARKED-VERB-PC-FLAG +,
                POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                VERB-PC59-FLAG #verb-pc59,
                VERB-PC60-FLAG #verb-pc60,
                VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ],
    DTR tense-marked-verb-pc-rule-dtr &
        [ INFLECTED [ POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                      VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                      VERB-PC59-FLAG #verb-pc59,
                      VERB-PC60-FLAG #verb-pc60,
                      VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                      NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                      1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ] ] ].

past-perf-verb-pc-lrt-lex-rule := infl-lex-rule & tense-marked-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ ASPECT pfv,
                                     TENSE pst ] ].

fut-verb-pc-lrt-lex-rule := infl-lex-rule & tense-marked-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE fut ].

present-verb-pc-lrt-lex-rule := const-lex-rule & tense-marked-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE prs ].

verb-pc13-lex-rule-super := add-only-no-ccont-rule & completed-verb-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc6-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc13_lrt1-lex-rule := verb-pc13-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT prosp ].

start-stop-verb-pc-lex-rule-super := add-only-no-ccont-rule & completed-verb-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR directive-verb-pc-or-start-stop-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc14_lrt1-lex-rule := start-stop-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT incep ].

verb-pc14_lrt2-lex-rule := start-stop-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT incep ].

habitual-verb-pc-lex-rule-super := add-only-no-ccont-rule & applicative-verb-pc-rule-dtr & causative-verb-pc-rule-dtr & completed-verb-rule-dtr & directive-verb-pc-or-start-stop-verb-pc-rule-dtr & go-pl-pc-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc33-rule-dtr & verb-pc7-rule-dtr & verb-pc9-rule-dtr &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

habitual-verb-pc-lrt-lex-rule := habitual-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT hab ].

verb-pc16-lex-rule-super := add-only-no-ccont-rule & completed-verb-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc1-rule-dtr & verb-pc23-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR verb-pc16-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc16_lrt1-lex-rule := verb-pc16-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pst ].

go-pl-pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & verb-pc23-rule-dtr &
  [ INFLECTED #infl,
    DTR go-pl-pc-rule-dtr &
        [ INFLECTED #infl ] ].

go-pl-pc-lrt-lex-rule := go-pl-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

desiderative-verb-pc-lrt-lex-rule := go-pl-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD desid ].

go-sg-verb-pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

go-sg-verb-pc-lrt-lex-rule := go-sg-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg ].

verb-pc23-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR verb-pc23-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc23_lrt1-lex-rule := verb-pc23-lex-rule-super.

object-relativizer-pc-lex-rule-super := infl-lex-rule & low-nmz-subjid-compsid-lex-rule & tense-marked-verb-pc-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc24_lrt1-lex-rule := object-relativizer-pc-lex-rule-super.

applicative-verb-pc-lex-rule-super := completed-verb-rule-dtr & directive-verb-pc-or-start-stop-verb-pc-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & val-change-with-ccont-lex-rule & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc7-rule-dtr & verb-pc9-rule-dtr &
  [ INFLECTED #infl,
    DTR applicative-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

intransitive-applicative-verb-pc-lrt-lex-rule := added-arg2of3-applicative-lex-rule & added-arg2of3-np-head-lex-rule & applicative-verb-pc-lex-rule-super & same-cont-lex-rule &
  [ C-CONT.RELS.LIST < [ PRED "_for_rel" ] > ].

transitive-applicative-verb-pc-lrt-lex-rule := added-arg2of2-applicative-lex-rule & added-arg2of2-np-head-lex-rule & applicative-verb-pc-lex-rule-super & same-cont-lex-rule &
  [ C-CONT.RELS.LIST < [ PRED "_for_rel" ] > ].

completed-verb-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc23-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR completed-verb-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc29_lrt1-lex-rule := completed-verb-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT cmpl ].

evidential-verb-pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

evidential-verb-pc-lrt-lex-rule := evidential-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD ev ].

irrealis-verb-pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR irrealis-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

irrealis-verb-pc-lrt-lex-rule := irrealis-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD irr ].

verb-pc32_lrt2-lex-rule := irrealis-verb-pc-lex-rule-super.

verb-pc33-lex-rule-super := completed-verb-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & val-change-with-ccont-lex-rule & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR verb-pc33-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc33_lrt1-lex-rule := added-arg2of2-applicative-lex-rule & added-arg2of2-np-head-lex-rule & same-cont-lex-rule & verb-pc33-lex-rule-super &
  [ C-CONT.RELS.LIST < [ PRED "caus_rel" ] >,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD ind ].

verb-pc37-lex-rule-super := add-only-no-ccont-rule & completed-verb-rule-dtr & infl-lex-rule & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc23-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc37_lrt1-lex-rule := verb-pc37-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

verb-pc38-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & verb-pc9-rule-dtr &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc38_lrt1-lex-rule := verb-pc38-lex-rule-super.

could-verb-pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

could-verb-pc_lrt-lex-rule := could-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD sbjv ].

redup1-verb-pc-lex-rule-super := add-only-no-ccont-rule & applicative-verb-pc-rule-dtr & completed-verb-rule-dtr & directive-verb-pc-or-start-stop-verb-pc-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc7-rule-dtr & verb-pc9-rule-dtr &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

hab-redupped-verb-pc-lex-rule := redup1-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT hab ].

prog-verb-pc-lex-rule-super := add-only-no-ccont-rule & applicative-verb-pc-rule-dtr & causative-verb-pc-rule-dtr & completed-verb-rule-dtr & directive-verb-pc-or-start-stop-verb-pc-rule-dtr & infl-lex-rule & irrealis-verb-pc-rule-dtr & past-impfv-verb-pc-rule-dtr & tense-marked-verb-pc-rule-dtr & verb-pc1-rule-dtr & verb-pc16-rule-dtr & verb-pc23-rule-dtr & verb-pc33-rule-dtr & verb-pc7-rule-dtr & verb-pc9-rule-dtr &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

prog-verb-pc_lrt-lex-rule := prog-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT prog ].

imp-verb-pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & tense-marked-verb-pc-rule-dtr & verb-pc7-rule-dtr &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

imp-verb-pc_lrt-lex-rule := imp-verb-pc-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD imp ].

when-verb-pc-lex-rule-super := infl-lex-rule & low-nmz-subjid-compsid-lex-rule &
  [ INFLECTED #infl,
    DTR could-verb-pc-or-evidential-verb-pc-or-go-sg-verb-pc-or-habitual-verb-pc-or-imp-verb-pc-or-object-relativizer-pc-or-prog-verb-pc-or-redup1-verb-pc-or-verb-pc13-or-verb-pc37-or-verb-pc38-or-when-verb-pc-rule-dtr &
        [ INFLECTED #infl ] ].

verb-pc58_lrt1-lex-rule := when-verb-pc-lex-rule-super.

verb-pc59-lex-rule-super := add-only-no-ccont-rule & const-lex-rule &
  [ INFLECTED [ VERB-PC59-OR-VERB-PC60-FLAG +,
                VERB-PC59-FLAG +,
                POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                VERB-PC60-FLAG #verb-pc60,
                TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ],
    DTR verb-pc59-rule-dtr &
        [ INFLECTED [ POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                      VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                      VERB-PC60-FLAG #verb-pc60,
                      TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                      NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                      1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ] ] ].

verb-pc59_lrt1-lex-rule := verb-pc59-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER non-1st,
                                                                NUM number ] ].

verb-pc60-lex-rule-super := add-only-no-ccont-rule & const-lex-rule &
  [ INFLECTED [ VERB-PC59-OR-VERB-PC60-FLAG +,
                VERB-PC60-FLAG +,
                POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                VERB-PC59-FLAG #verb-pc59,
                TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ],
    DTR verb-pc60-rule-dtr &
        [ INFLECTED [ POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                      VERB-PC61-OR-VERB-PC62-FLAG #verb-pc61-or-verb-pc62,
                      VERB-PC59-FLAG #verb-pc59,
                      TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                      NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                      1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ] ] ].

verb-pc60_lrt1-lex-rule := verb-pc60-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd,
                                                                NUM sg ] ].

verb-pc61-lex-rule-super := add-only-no-ccont-rule & const-lex-rule &
  [ INFLECTED [ VERB-PC61-OR-VERB-PC62-FLAG +,
                POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                VERB-PC59-FLAG #verb-pc59,
                VERB-PC60-FLAG #verb-pc60,
                TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ],
    DTR aux2-aux-lex &
        [ INFLECTED [ POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                      VERB-PC59-FLAG #verb-pc59,
                      VERB-PC60-FLAG #verb-pc60,
                      TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                      VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                      NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                      1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ] ] ].

verb-pc61_lrt1-lex-rule := verb-pc61-lex-rule-super.

verb-pc62-lex-rule-super := add-only-no-ccont-rule & const-lex-rule &
  [ INFLECTED [ VERB-PC61-OR-VERB-PC62-FLAG +,
                POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                VERB-PC59-FLAG #verb-pc59,
                VERB-PC60-FLAG #verb-pc60,
                TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ],
    DTR aux2-aux-lex &
        [ INFLECTED [ POSSESSED-MARKED-AA-NOUN-FLAG #possessed-marked-aa-noun,
                      VERB-PC59-FLAG #verb-pc59,
                      VERB-PC60-FLAG #verb-pc60,
                      TENSE-MARKED-VERB-PC-FLAG #tense-marked-verb-pc,
                      VERB-PC59-OR-VERB-PC60-FLAG #verb-pc59-or-verb-pc60,
                      NUMBERED-CASED-NOUN_PC-FLAG #numbered-cased-noun_pc,
                      1ST-SG-NOM-PRONOUN-NOUN-OR-2ND-SG-NOM-PRONOUN-NOUN-OR-GENERIC-PRONOUN-NOUN-FLAG #1st-sg-nom-pronoun-noun-or-2nd-sg-nom-pronoun-noun-or-generic-pronoun-noun ] ] ].

verb-pc62_lrt1-lex-rule := verb-pc62-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 1st,
                                                                NUM pl ] ].

think_inflected_adj_pc-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR basic_adjective-adj-lex &
        [ INFLECTED #infl ] ].

think_inflected_adj_pc_lrt-lex-rule := think_inflected_adj_pc-lex-rule-super.

added-arg2of2-non-local-lex-rule := lex-rule.

scopal-rel-lex-rule := lex-rule &
  [ C-CONT [ RELS.LIST < event-relation &
                         [ LBL #ltop,
                           ARG0 #hidx,
                           ARG1 #arg1,
                           ARG2 #arg2,
                           ARG3 #harg ] >,
             HOOK [ LTOP #ltop,
                    INDEX #hidx,
                    XARG #arg1 ],
             HCONS.LIST < qeq &
                          [ HARG #harg,
                            LARG #scoped ] > ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #arg1 ] >,
    DTR.SYNSEM.LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #arg2 ] >,
                       CONT.HOOK.LTOP #scoped ] ].

added-arg2of2-np-head-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD noun ] > ].

causative-to-arg2-itr-op-lex-rule := scopal-rel-lex-rule & same-spr-lex-rule & same-spec-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CAT.VAL [ SPR < >,
                                                    COMPS < > ] ] >,
                           COMPS < [ LOCAL [ CONT.HOOK.INDEX #arg2,
                                             CAT [ HEAD [ MOD #mod,
                                                          KEYS #keys ],
                                                   VAL #val ] ],
                                     NON-LOCAL #nl ] > ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #arg2,
                                                CAT [ HEAD [ MOD #mod,
                                                             KEYS #keys ],
                                                      VAL #val ] ],
                                        NON-LOCAL #nl ] >,
                               COMPS < > ] ].

added-arg2of2-applicative-lex-rule := basic-applicative-lex-rule & added-arg2of2-non-local-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.VAL [ SPR < >,
                                                     COMPS < > ],
                                           CONT.HOOK.INDEX #nind ] ] >,
    C-CONT.RELS.LIST < [ ARG2 #nind ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

basic-applicative-lex-rule := comps-change-only-lex-rule &
  [ C-CONT [ RELS.LIST < event-relation &
                         [ ARG1 #evt ] >,
             HCONS.LIST < > ],
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #evt ].

added-arg2of3-non-local-lex-rule := lex-rule.

causative-to-arg2-tr-op-lex-rule := scopal-rel-lex-rule & same-spr-lex-rule & same-spec-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CAT.VAL [ SPR < >,
                                                    COMPS < > ] ] >,
                           COMPS < [ LOCAL [ CONT.HOOK.INDEX #arg2,
                                             CAT [ HEAD [ MOD #mod,
                                                          KEYS #keys ],
                                                   VAL #val ] ],
                                     NON-LOCAL #nl ],
                                   #comp > ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #arg2,
                                                CAT [ HEAD [ MOD #mod,
                                                             KEYS #keys ],
                                                      VAL #val ] ],
                                        NON-LOCAL #nl ] >,
                               COMPS < #comp > ] ].

added-arg2of3-np-head-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD noun ],
                                 [ ] > ].

added-arg2of3-applicative-lex-rule := basic-applicative-lex-rule & added-arg2of3-non-local-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT.VAL [ SPR < >,
                                                     COMPS < > ],
                                           CONT.HOOK.INDEX #nind ] ],
                                 #ocomp >,
    C-CONT.RELS.LIST < [ ARG2 #nind ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < #ocomp > ].

;;;;;;;;;;;;;;;;;;;
;;; Phrasal Types
;;;;;;;;;;;;;;;;;;;

my-head-adj-phrase := head-adj-int-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD +nvr,
                                VAL [ SUBJ clist,
                                      COMPS clist ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD +jrp,
                                    VAL.COMPS < > ] ].

my-adj-head-phrase := adj-head-int-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD +nvr,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD +jrp,
                                    VAL.COMPS < > ] ].

; non-event-subj-head-phrase := basic-head-subj-phrase & head-final &
;   [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
;     HEAD-DTR.SYNSEM [ NON-LOCAL [ QUE.LIST < >,
;                                   REL.LIST < > ],
;                       LOCAL [ CONT.HOOK.INDEX ref-ind,
;                               CAT.VAL.COMPS < > ] ] ].

;Constraint on MC used to be part of matrix.tdl
;;it applies to all wo implementations, except for v2

; The head of comp-head-phrase can't be: ['adp']

comp-head-phrase := basic-head-1st-comp-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD +nvjrcdmo,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INIT - ].

; Also disallow adpositions as heads
subj-head-phrase := decl-head-subj-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD +nvjrcdmo ,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NONHEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun ] .

poss-unary-phrase-pron-1 := poss-unary-phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.POSSESSOR possessor-pron-1 ] >,
    SYNSEM.LOCAL.CAT [ HEAD.SPEC-INIT +,
                       VAL.SPEC.FIRST.LOCAL.CAT.POSSESSUM nonpossessive ] ].

poss-unary-phrase := basic-unary-phrase &
  [ SYNSEM [ NON-LOCAL #nonloc,
             LOCAL [ CONT.HOOK #hook,
                     CAT [ HEAD det &
                                [ POSSESSOR possessor ],
                           VAL [ SPR < >,
                                 COMPS < >,
                                 SUBJ < >,
                                 SPEC < [ LOCAL [ CAT [ VAL.COMPS < >,
                                                        HEAD noun &
                                                             [ PRON - ] ],
                                                  CONT.HOOK #hook &
                                                            [ INDEX #possessum &
                                                                    [ COG-ST uniq-id ],
                                                              LTOP #lbl ] ] ] > ] ] ] ],
    C-CONT [ RELS.LIST < arg12-ev-relation &
                         [ PRED "poss_rel",
                           LBL #lbl,
                           ARG1 #possessum,
                           ARG2 #possessor ],
                         quant-relation &
                         [ PRED "exist_q_rel",
                           ARG0 #possessum,
                           RSTR #harg ] >,
             HCONS.LIST < qeq &
                          [ HARG #harg,
                            LARG #lbl ] >,
             ICONS.LIST < > ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ VAL [ SPR < >,
                                          COMPS < >,
                                          SUBJ < >,
                                          SPEC < > ],
                                    HEAD noun ],
			      COORD -,
                              CONT.HOOK.INDEX #possessor ],
                      NON-LOCAL #nonloc ] ] > ].

;Constraint on MC used to be part of matrix.tdl
;;it applies to all wo implementations, except for v2

poss-unary-phrase-pron-2 := poss-unary-phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.POSSESSOR possessor-pron-2 ] >,
    SYNSEM.LOCAL.CAT [ HEAD.SPEC-INIT +,
                       VAL.SPEC.FIRST.LOCAL.CAT.POSSESSUM possessum-pron-2 ] ].

;Constraint on MC used to be part of matrix.tdl
;;it applies to all wo implementations, except for v2

; Bare NP phrase.  Consider modifying the PRED value of the quantifier relation
; introduced to match the semantic effect of bare NPs in your language.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS.LIST < [ PRED "exist_q_rel" ] >,
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.CASE #case,
                            CONT.HOOK.INDEX.PNG #png ],
    SYNSEM [ LOCAL [ CAT.HEAD.CASE #case,
                     CONT.HOOK.INDEX.PNG #png ],
             LIGHT - ] ].

; head-comp-phrase requires things that are [ HEAD adp ].

head-comp-phrase := basic-head-1st-comp-phrase & head-initial &
  [ ;SYNSEM.LOCAL.CAT.HEAD adp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb &
                                   [ INIT + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM finite ].
    
;;; Head Adjunct rules

; For intersective adjuncts with underspecified attachment locations:

;;; Wh-question-related phrasal types

wh-ques-phrase := basic-head-filler-phrase & interrogative-clause & head-final &
  [ SYNSEM [ LOCAL.CAT [ WH.BOOL +,
                         MC bool,
                         VAL #val,
                         HEAD verb ],
             NON-LOCAL.QUE.LIST < > ],
    NON-HEAD-DTR.SYNSEM [ NON-LOCAL.QUE.LIST < ref-ind >,
                          LOCAL.CONT.HOOK.ICONS-KEY focus ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL #val &
                                    [ SUBJ < >,
                                      COMPS < > ],
                                MC na-or-+ ] ].

; Complement extraction

; Adjunct extraction

basic-filler-phrase :+ [ SYNSEM.NON-LOCAL.SLASH.LIST < >,
    ARGS < [ SYNSEM [ LOCAL #slash,
                      NON-LOCAL.SLASH.LIST < > ] ],
           [ SYNSEM.NON-LOCAL.SLASH.LIST < #slash > ] > ].

; In-situ interrogative clause.

extracted-det-phrase := basic-extracted-arg-phrase & head-compositional &
  [ SYNSEM [ LOCAL #specloc & local &
                   [ CAT.VAL [ SUBJ < >,
                               COMPS < >,
                               SPR < >,
                               SPEC < > ] ],
             NON-LOCAL.SLASH.APPEND < #slash,
                                      [ LIST < #local > ] > ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.VAL.SPR < gap &
                                          [ LOCAL #local & local &
                                                  [ CAT [ HEAD det,
                                                          VAL.SPEC.FIRST.LOCAL #specloc ],
                                                    CONT.HOOK #hook ] ] >,
                      NON-LOCAL.SLASH #slash ],
    C-CONT [ RELS.LIST < >,
             HCONS.LIST < >,
             ICONS.LIST < >,
             HOOK #hook ] ].

;;;;;;;;;;;;;;;;;;
;;; Coordination
;;;;;;;;;;;;;;;;;;

adv1-top-coord-rule := basic-adv-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

adv1-mid-coord-rule := basic-adv-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

adv1-bottom-coord-rule := conj-first-bottom-coord-rule & adv-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;; Coordination Strategy 2

vp2-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

vp2-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

vp2-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

;;; Coordination Strategy 3

vp3-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "3" ].

vp3-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "3" ].

vp3-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "3" ].

;;; Coordination Strategy 5

vp5-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

vp5-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

vp5-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

;;; Feature Resolution Rules

pass-up-png-coord-rule := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE #case,
                   CONT.HOOK.INDEX.PNG #png ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD.CASE #case,
                               CONT.HOOK.INDEX.PNG #png ] ].

same-same-same-case-coord-rule := coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case ].

;;; Coordination Strategy 6

np6-same-same-same-top-coord-rule := basic-np-top-coord-rule & monopoly-top-coord-rule & same-same-same-case-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "6" ].

np6-same-same-same-mid-coord-rule := basic-np-mid-coord-rule & monopoly-mid-coord-rule & same-same-same-case-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "6" ].

np6-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase & pass-up-png-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "6" ].

;;; Feature Resolution Rules

;;; Coordination Strategy 8

np8-same-same-same-top-coord-rule := basic-np-top-coord-rule & monopoly-top-coord-rule & same-same-same-case-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "8" ].

np8-same-same-same-mid-coord-rule := basic-np-mid-coord-rule & monopoly-mid-coord-rule & same-same-same-case-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "8" ].

np8-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase & pass-up-png-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "8" ].

;;; Feature Resolution Rules

;;; Coordination Strategy 9

np9-same-same-same-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule & same-same-same-case-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "9" ].

np9-bottom-coord-rule := unary-bottom-coord-rule & np-bottom-coord-phrase & pass-up-png-coord-rule &
  [ SYNSEM.LOCAL [ COORD-STRAT "9",
                   COORD-REL.PRED "_and_coord_rel" ] ].

;;; Feature Resolution Rules

;;; Coordination Strategy 10

np10-same-same-same-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule & same-same-same-case-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "10" ].

np10-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase & pass-up-png-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "10" ].

;;; Coordination Strategy 11

s11-top-coord-rule := basic-s-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "11" ].

s11-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "11" ].

; Do not allow extracting "And Kim"

basic-head-filler-phrase :+ [ ARGS < [ SYNSEM.LOCAL.COORD - ],
           [ SYNSEM.LOCAL.COORD - ] > ].

extracted-comp-phrase := basic-extracted-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons ].

extracted-subj-phrase := basic-extracted-subj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.HEAD verb ].

; Subject extraction

phrase-or-lexrule :+ [ SYNSEM.L-QUE #lque,
    ARGS.FIRST.SYNSEM.L-QUE #lque ].

insitu-int-cl := interrogative-clause & head-only &
  [ C-CONT [ RELS.LIST < >,
             HCONS.LIST < > ],
    SYNSEM [ MODIFIED hasmod,
             NON-LOCAL [ SLASH.LIST < >,
                         QUE.LIST < >,
                         REL.LIST < > ],
             LOCAL.CAT [ VAL #val,
                         MC bool,
                         WH.BOOL - ] ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb,
                                  VAL #val &
                                      [ SUBJ < >,
                                        COMPS < > ] ],
                      NON-LOCAL [ SLASH.LIST < >,
                                  REL.LIST < >,
                                  QUE.LIST.FIRST ref-ind ],
                      L-QUE - ] ].
;; Adpositions
locative-pp-phrase := unary-phrase &
[ SYNSEM [ NON-LOCAL #nl,
           LOCAL [ CAT [ HEAD adp & [ ;PRD -,
				      MOD < [ LOCAL intersective-mod &
                                                    [ CAT.HEAD verb,
                                                      CONT.HOOK.INDEX #xarg ] ] > ],
		          VAL [ COMPS < >,
			        SUBJ < >,
				SPEC < >,
			        SPR < > ] ],
		COORD - ] ],
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX #index,
		    XARG #xarg ],
	  RELS.LIST < arg12-ev-relation &
		   [ PRED "_loc_p_rel",
		     LBL #ltop,
		     ARG0 #index,
		     ARG1 #xarg,
		     ARG2 #dtr ] >,
	     HCONS.LIST < >  ],
	  ARGS < [ SYNSEM [ NON-LOCAL #nl,
		            LOCAL [ CAT [ HEAD noun & [CASE loc],
		                          VAL [ SPR < >,
						COMPS < >],
					  POSSESSUM nonpossessive ],
				    COORD -,
			            CONT.HOOK [ INDEX #dtr ]]]] > ].
;; Stand-alone NP predicates
n-bar-predicate-rule := unary-phrase & nocoord &
  [ SYNSEM [ LOCAL.CAT [ HEAD verb , 
                   VAL [
		   SPR < >,
		   COMPS < >,
		   SPEC < >,
                   SUBJ < [ LOCAL [ CONT.HOOK.INDEX #arg1,
                             CAT [ HEAD noun & [ CASE nom ],
                      VAL.SPR < > ] ] ] > ] ],
             NON-LOCAL #nl ],
    C-CONT [ HOOK [ LTOP #ltop,
            INDEX #index,
            XARG #arg1 ],
         RELS.LIST < arg12-ev-relation &
           [ PRED "_be_v_id_rel",
             LBL #ltop,
             ARG0 #index,
             ARG1 #arg1,
             ARG2 #arg2 ],
           quant-relation &
           [ PRED "exist_q_rel",
             ARG0 #arg2,
             RSTR #harg ] >,
         HCONS.LIST < qeq & [ HARG #harg, LARG #larg ] > ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [CASE nom],
                     VAL.SPR cons ],
                  CONT.HOOK [ INDEX #arg2,
                                      LTOP #larg ]],
                  NON-LOCAL #nl ] ] > ].

neg-adverb-phrase := adj-head-scop-phrase &
[ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv ].
